/* jshint node:true, undef:true, unused:true */

var recast      = require('recast');
var esprima     = require('esprima');
var through     = require('through');
var types       = recast.types;
var n           = types.namedTypes;
var b           = types.builders;
var stringType  = types.builtInTypes.string;


function pushAll(arr, data) {
    arr.push.apply(arr, data);
}


function isPattern(node) {
  return (n.ObjectPattern.check(node) || n.ArrayPattern.check(node));
}

var uidVar = 0,
    uidArg = 0;

/**
 * Visits a node of an AST looking for VariableDeclaration and FunctionDeclaration expressions. and
 * desugar destructuration if needed
 *
 * @param {Object} node
 * @this {ast-types.Path}
 */
function visitNode(node) {
    if (n.VariableDeclaration.check(node)) {
        node.declarations = node.declarations.reduce(
            function (declarations, decl) {
                var id = decl.id;
                if(isPattern(id)) {
                    pushAll(declarations, createVariableDeclarationsFromPattern(decl.id, decl.init));   
                } else {
                    declarations.push(decl); 
                }
                return declarations;
            }, []
        );
    } else if(n.FunctionDeclaration.check(node) || n. FunctionExpression.check(node)) {
        var declarations = [];
        // loop over function parameters and replace all destructuration patterns
        // with synthesized parameters, collect all found patterns to process them
        // later
        node.params = node.params.map(function(param) {
            if (isPattern(param)) {
                var id = b.identifier('arg$'+ (uidArg++));
                pushAll(declarations, createVariableDeclarationsFromPattern(param, id));
                return id;
            } 
            return param;
        });
        if (declarations.length) {
            node.body.body.unshift(b.variableDeclaration('var', declarations));
        }
    } else {
        return;
    }
}


/**
 * from a given destructuration pattern, and associated value expression
 * create variable declarations that desugar these pattern
 * 
 * @param {Node} pattern the destructuration pattern
 * @param {Node} expr the value expression to destructure
 */
function createVariableDeclarationsFromPattern(pattern, expr) {
    var id;
    var results = [];
    if (n.ObjectPattern.check(pattern) && pattern.properties.length === 1) {
        id = expr;
    } else if (n.ArrayPattern.check(pattern) && pattern.elements.length === 1) {
        id = expr;
    } else if (n.Identifier.check(expr) || stringType.check(expr)) {
        id = expr;
    } else {
        id = b.identifier('var$' + (uidVar++));
        results.push(b.variableDeclarator(id, expr)); 
    }
    
    if (n.ObjectPattern.check(pattern)) {
        pattern.properties.forEach(function(prop) {
            var value = b.memberExpression(id, prop.key, false);
            if (isPattern(prop.value)) {
                pushAll(results, createVariableDeclarationsFromPattern(prop.value, value));
            } else {
                results.push(b.variableDeclarator(b.identifier(prop.value.name), value));
            }
        });
    } else {
        pattern.elements.forEach(function(elem, idx) {
            // null means skip
            if (elem === null) {
                return;
            }
            
            if (!n.SpreadElement.check(elem)) {
                var value = b.memberExpression(id, b.literal(idx), true);
                if (isPattern(elem)) {
                    pushAll(results, createVariableDeclarationsFromPattern(elem, value));
                } else  {
                    results.push(b.variableDeclarator(b.identifier(elem.name), value));
                }  
            } else {
                results.push(b.variableDeclarator(
                    b.identifier(elem.argument.name),
                    b.callExpression(
                        b.memberExpression(id, b.identifier('slice'), false),
                        [b.literal(idx)]
                    )
                ));
            }
        });
    }
    
    return results;
}

/**
 * Transform an Esprima AST generated by desugaring all destructuration expression
 *
 * NOTE: The argument may be modified by this function. To prevent modification
 * of your AST, pass a copy instead of a direct reference:
 *
 *   // instead of transform(ast), pass a copy
 *   transform(JSON.parse(JSON.stringify(ast));
 *
 * @param {Object} ast
 * @return {Object}
 */
function transform(ast) {
    uidVar = uidArg = 0;
    return types.traverse(ast, visitNode);
}

/**
 * Transform JavaScript written using ES6 by desugaring all destructuring
 *
 *   compile('var {x, y} = z'); // 'var x = z.x, y = z.y'
 *
 * @param {string} source
 * @return {string}
 */
function compile(source, mapOptions) {
    mapOptions = mapOptions || {};

    var recastOptions = {
        // Use the harmony branch of Esprima that installs with this project
        // instead of the master branch that recast provides.
        esprima: esprima,

        sourceFileName: mapOptions.sourceFileName,
        sourceMapName: mapOptions.sourceMapName
    };

    var ast = recast.parse(source, recastOptions);
    return recast.print(transform(ast), recastOptions);
}

module.exports = function() {
    var data = '';
    return through(write, end);

    function write(buf) { data += buf; }
    function end() {
        this.queue(module.exports.compile(data).code);
        this.queue(null);
    }
};

module.exports.compile = compile;
module.exports.transform = transform;